@using Simple_CSharp_Games.Models
@using Simple_CSharp_Games.Models.FinalBattle

<div class="finalbattle-game-container">

	@if ( finalBattle.BattlePhase == BattlePhase.Setup )
	{
		<h1>@GameTitle</h1>

		<div class="hero-input-container">
			<label for="heroName">Enter Your Hero's Name:</label>
			<input 
			id="heroName"
            tabindex="0"
			type="text"
			class="m-2 p-1"
			min="0"
			max="9"
			@bind-value="heroName"
			@bind-value:event="oninput"
			@onkeydown="StartGameKeyHandler" 
			/>
		</div>

		<button class="btn btn-primary" @onclick="StartGame">Start Battle</button>
	}

	@if (finalBattle.BattlePhase != BattlePhase.Outcome && finalBattle.GameWinner == null)
	{

		<div class="battle-messages-container">
			@if (finalBattle.BattlePhase != BattlePhase.Setup)
			{
				<p> @finalBattle.CurrentTurnLabel </p>

				<p>@finalBattle.LastLogEntry</p>
			}

		</div>

		<div class="battle-parties-container">

			<div class="battle-heroes-container">
				@for (int i = 0; i < finalBattle._battleGame.Heroes.Count; i++)
				{
					var hero = finalBattle._battleGame.Heroes[i];
					<img 
					class="battle-avatar-image"
					src="@($"{GetAvatarUrl(hero.Type)}")"
					alt="@($"{hero.Name} Avatar Image")" 
					/>
					<p>@hero.Name</p>
					<p>hp: @hero.CurrentHP/@hero.MaxHP</p>
				}
			</div>

			<div class="battle-monsters-container">
				@for (int i = 0; i < finalBattle._battleGame.Monsters[finalBattle.CurrentMonsterPartyIndex].Count; i++)
				{
					var monster = finalBattle._battleGame.Monsters[finalBattle.CurrentMonsterPartyIndex][i];
					<img class="battle-avatar-image"
					src="@($"{GetAvatarUrl(monster.Type)}")"
					alt="@($"{monster.Name} Avatar Image")" />
					<p>@monster.Name</p>
					<p>hp: @monster.CurrentHP/@monster.MaxHP</p>
				}
			</div>
		</div>

		@if (finalBattle.BattlePhase == BattlePhase.HeroAwaitInput && finalBattle.GameWinner == null)
		{
			var actionList1 = finalBattle.GetAvailableActions();
			var max = actionList1?.Count - 1;
			<div class="hero-actions-container">
				@for (int i = 0; i < actionList1?.Count; i++)
				{
					var action = actionList1[i];
					var index = i + 1; // Adjust index for display purposes
					<p>@index - @action.Key</p>
				}
			</div>

			// add an input tot set the correct index value for the action
			<div class="hero-actionChoice-container">
				<label for="actionChoice">Choose An Action:</label>
				<input id="actionChoice"
				type="number"
				class="m-2 p-1"
				min="1"
				max="@max"
				@bind-value="actionChoiceIndex"
				@bind-value:event="oninput"
				@onkeydown="HeroActionHandler" />
			</div>
			<button disabled="@((actionChoiceIndex == null ))"
				class="btn btn-primary" 
				@onclick="HeroesTurn"
			>
				Perform Action
			</button>
		}

		@if (finalBattle.BattlePhase == BattlePhase.MonsterResolving && finalBattle.GameWinner == null)
		{
			<button tabindex="0" class="btn btn-primary" @onclick="MonstersTurn">Test Monsters</button>
		}


	}

	@if (finalBattle.BattlePhase == BattlePhase.Outcome && finalBattle.GameWinner != null)
	{
		<div class="battle-winner-container">
			@* <p>Winner: @finalBattle?.GameWinner</p> *@
			<p>@finalBattle?.LastLogEntry</p>

			<button class="btn btn-primary" @onclick="PlayAgain">Play Again</button>

		</div>
	}

</div>

@code {
	private string GameTitle = "The Final Battle";

	BattleGameState finalBattle = new BattleGameState();

	private string? heroName;

	private int? actionChoiceIndex;

	private List<string>? battleLog;

	private List<KeyValuePair<string, IBehavior>>? actionList;


	private void StartGame()
	{
		if (heroName != null)
			finalBattle.SetUp(heroName);

		battleLog = finalBattle.BattleLog;
	}


	private void PlayAgain()
	{
		finalBattle = new BattleGameState();
		heroName = null;

		finalBattle.BattlePhase = BattlePhase.Setup;
		finalBattle.ActiveHeroIndex = 0;
		finalBattle.CurrentMonsterPartyIndex = 0;

		finalBattle.BattleLog.Clear();
		finalBattle._battleGame.Winner = null;
		finalBattle.CurrentTurnLabel = "";

	}

	// update to take choice arguments form user inputs
	private void HeroesTurn()
	{
		// Get the current hero
		var hero = finalBattle._battleGame.Heroes[finalBattle.ActiveHeroIndex];

		var actions = finalBattle.GetAvailableActions();

		// ensure hero has actions in list
		if (actions == null || actions.Count == 0)
		{
			battleLog?.Add($"{hero.Name} has no available actions.");
			return;
		}

		var index = (actionChoiceIndex ?? 0) - 1;

		if (index < 0 || index >= actions.Count)
		{
			battleLog?.Add("Invalid action choice. Please select a valid option.");
			return;
		}

		var actionId = actions[index].Key;

		if (string.IsNullOrWhiteSpace(actionId))
		{
			battleLog?.Add($"{hero.Name} has no available actions.");
			return;
		}

		// Find the first alive monster in the current wave
		var monsters = finalBattle._battleGame.Monsters[finalBattle.CurrentMonsterPartyIndex];

		var targetIndex = -1;

		for (int i = 0; i < monsters.Count; i++)
		{
			if (monsters[i].CurrentHP > 0)
			{
				targetIndex = i;
				break;
			}
		}

		if (targetIndex == -1)
		{
			battleLog?.Add("No valid monster targets remain in this wave.");
			return;
		}

		// Execute the hero action against the chosen target
		finalBattle.ResolveHeroAction(actionId, targetIndex.ToString());

		actionChoiceIndex = null; // Reset the action choice index after the action is performed
	}

	private void MonstersTurn()
	{
		finalBattle.ResolveMonsterTurn();
	}

	private string GetAvatarUrl( CharacterTypes characterType)
	{
		return characterType switch
		{
			CharacterTypes.Hero => "/images/battle/hero_avatar.png",
			CharacterTypes.Fletcher => "/images/battle/fletcher_avatar.png",
			CharacterTypes.Skeleton => "/images/battle/skeleton_avatar.png",
			CharacterTypes.Uncoded => "/images/battle/uncoded_avatar.png",
			_ => "/images/battle/fletcher_avatar.png"
		};
	}

	private async Task StartGameKeyHandler(KeyboardEventArgs e)
	{
		if (e.Key == "Enter")
		{
			StartGame();
			await Task.CompletedTask;
		}
	}

	private async Task HeroActionHandler(KeyboardEventArgs e)
	{

		if (e.Key == "Enter" && actionChoiceIndex != null)
		{
			HeroesTurn();
			await Task.CompletedTask;
		}
	}
}
